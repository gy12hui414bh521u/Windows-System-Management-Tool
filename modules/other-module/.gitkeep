#include "pch.h"
#include "StringUtilsDLL.h"
#include <cstring>   // 用于 strcpy_s、strlen、strstr 等字符串函数
#include <cctype>    // 用于 toupper、tolower 大小写转换

// 定义导出宏（仅 DLL 编译时生效）
#define STRINGUTILSDLL_EXPORTS

// 存储最后一次错误信息（静态局部变量，线程安全基础保障）
static char g_lastError[256] = { 0 };

// -------------- 工具函数：设置错误信息 --------------
void SetLastError(const char* errorMsg) {
    if (errorMsg) {
        // 避免字符串溢出，截断过长的错误信息
        strncpy_s(g_lastError, sizeof(g_lastError), errorMsg, _TRUNCATE);
    }
    else {
        g_lastError[0] = '\0'; // 清空错误信息
    }
}

// -------------- 接口实现 --------------
// 1. 字符串拼接
uint32_t String_Concat(const char* str1, const char* str2, char* outBuf, uint32_t bufSize) {
    SetLastError("");

    // 入参合法性检查
    if (!str1 || !str2 || !outBuf || bufSize == 0) {
        SetLastError("错误：空指针或缓冲区大小为0");
        return 0;
    }

    // 计算需要的总长度（str1长度 + str2长度 + 1个结束符'\0'）
    uint32_t len1 = static_cast<uint32_t>(strlen(str1));
    uint32_t len2 = static_cast<uint32_t>(strlen(str2));
    uint32_t totalLen = len1 + len2;

    // 检查缓冲区是否足够
    if (totalLen + 1 > bufSize) {
        SetLastError("错误：缓冲区不足，无法容纳拼接结果");
        return 0;
    }

    // 执行拼接（先复制str1，再追加str2）
    strcpy_s(outBuf, bufSize, str1);
    strcat_s(outBuf, bufSize, str2);

    return totalLen;
}

// 2. 字符串大小写转换
uint32_t String_ConvertCase(const char* src, char* outBuf, uint32_t bufSize, CaseConvertType type) {
    SetLastError("");

    if (!src || !outBuf || bufSize == 0) {
        SetLastError("错误：空指针或缓冲区大小为0");
        return 0;
    }

    uint32_t srcLen = static_cast<uint32_t>(strlen(src));
    if (srcLen + 1 > bufSize) {
        SetLastError("错误：缓冲区不足，无法容纳转换结果");
        return 0;
    }

    // 逐字符转换
    for (uint32_t i = 0; i < srcLen; i++) {
        if (type == CASE_UPPER) {
            outBuf[i] = static_cast<char>(toupper(static_cast<unsigned char>(src[i])));
        }
        else {
            outBuf[i] = static_cast<char>(tolower(static_cast<unsigned char>(src[i])));
        }
    }
    outBuf[srcLen] = '\0'; // 手动添加字符串结束符

    return srcLen;
}

// 3. 去除字符串两端空格
uint32_t String_Trim(const char* src, char* outBuf, uint32_t bufSize) {
    SetLastError("");

    if (!src || !outBuf || bufSize == 0) {
        SetLastError("错误：空指针或缓冲区大小为0");
        return 0;
    }

    uint32_t srcLen = static_cast<uint32_t>(strlen(src));
    if (srcLen == 0) { // 空字符串直接返回
        outBuf[0] = '\0';
        return 0;
    }

    // 找到左端第一个非空格字符的索引
    uint32_t left = 0;
    while (left < srcLen && isspace(static_cast<unsigned char>(src[left]))) {
        left++;
    }

    // 找到右端最后一个非空格字符的索引
    uint32_t right = srcLen - 1;
    while (right > left && isspace(static_cast<unsigned char>(src[right]))) {
        right--;
    }

    // 计算处理后字符串长度
    uint32_t trimLen = right - left + 1;
    if (trimLen + 1 > bufSize) {
        SetLastError("错误：缓冲区不足，无法容纳处理结果");
        return 0;
    }

    // 复制处理后的字符串到输出缓冲区
    strncpy_s(outBuf, bufSize, src + left, trimLen);
    outBuf[trimLen] = '\0';

    return trimLen;
}

// 4. 子串查找
int32_t String_FindSubStr(const char* src, const char* subStr) {
    SetLastError("");

    if (!src || !subStr) {
        SetLastError("错误：空指针（原字符串或子串为空）");
        return -1;
    }

    // 使用标准库 strstr 查找子串（返回子串首地址，NULL表示未找到）
    const char* found = strstr(src, subStr);
    if (!found) {
        SetLastError("提示：未找到指定子串");
        return -1;
    }

    // 计算索引（子串地址 - 原字符串地址）
    return static_cast<int32_t>(found - src);
}

// 5. 获取 DLL 功能描述
const char* String_GetDllDesc() {
    return "StringUtilsDLL：无需外部库，提供字符串拼接、大小写转换、两端空格去除、子串查找功能。";
}

// 6. 获取最后一次错误信息
const char* String_GetLastError() {
    return g_lastError;
}

// -------------- DLL 入口函数（固定模板，无需修改）--------------
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:  // DLL 被进程加载时
    case DLL_THREAD_ATTACH:   // 进程创建新线程时
    case DLL_THREAD_DETACH:   // 线程退出时
    case DLL_PROCESS_DETACH:  // DLL 被进程卸载时
        break;
    }
    return TRUE; // 初始化/卸载成功
}
